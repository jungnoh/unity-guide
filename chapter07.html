<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 7: UI and Canvas System - Unity Game Development Guide</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div style="display: flex; align-items: center; gap: 1rem;">
            <button class="menu-toggle" onclick="toggleSidebar()">â˜°</button>
            <h1>
                <div class="unity-logo">U</div>
                Unity Development Guide
            </h1>
        </div>
        <div style="display: flex; align-items: center; gap: 1rem;">
            <span style="color: var(--text-muted);">Chapter 7</span>
        </div>
    </header>

    <!-- Progress Bar -->
    <div class="progress-bar">
        <div class="progress-fill" id="progressBar"></div>
    </div>

    <!-- Sidebar Navigation -->
    <nav class="sidebar" id="sidebar">
        <h2>Getting Started</h2>
        <ul>
            <li><a href="index.html">ðŸ“š Introduction</a></li>
        </ul>

        <h2>Part I: Foundations</h2>
        <ul>
            <li><a href="chapter01.html">Ch 1: Unity Fundamentals</a></li>
            <li><a href="chapter02.html">Ch 2: Unity Editor & Setup</a></li>
            <li><a href="chapter03.html">Ch 3: GameObjects & Components</a></li>
            <li><a href="chapter04.html">Ch 4: C# Scripting in Unity</a></li>
        </ul>

        <h2>Part II: Core Systems</h2>
        <ul>
            <li><a href="chapter05.html">Ch 5: Input & Player Control</a></li>
            <li><a href="chapter06.html">Ch 6: Physics & Collisions</a></li>
            <li><a href="chapter07.html" class="active">Ch 7: UI & Canvas System</a></li>
            <li><a href="chapter08.html">Ch 8: Audio & Visual Effects</a></li>
            <li><a href="chapter09.html">Ch 9: Scene Management</a></li>
        </ul>

        <h2>Part III: Complete Project</h2>
        <ul>
            <li><a href="chapter10.html">Ch 10: Your First Game</a></li>
            <li><a href="chapter11.html">Ch 11: Performance</a></li>
            <li><a href="chapter12.html">Ch 12: Deployment</a></li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <div class="fade-in">
        <article class="chapter">
            <header class="chapter-header">
                <div class="chapter-number">Chapter 7</div>
                <h1>UI and Canvas System</h1>
                <p class="chapter-description">Build responsive, accessible user interfaces using Unity's Canvas system and UI components</p>
            </header>

            <section class="learning-objectives">
                <h2>What You'll Learn</h2>
                <ul>
                    <li>Unity's Canvas system and render modes</li>
                    <li>Responsive UI design with anchoring and scaling</li>
                    <li>Event-driven UI programming patterns</li>
                    <li>Advanced UI components and custom controls</li>
                    <li>UI animation and visual feedback systems</li>
                    <li>Performance optimization for complex UIs</li>
                </ul>
            </section>

            <section>
                <h2>Understanding Unity's UI Architecture</h2>
                
                <p>Unity's UI system is built around a component-based architecture that will feel familiar if you've worked with modern web frameworks like React or Vue. Just as you compose web interfaces from components like buttons, inputs, and containers, Unity UI uses a hierarchy of UI elements that inherit behavior and styling from their parents.</p>

                <p>The fundamental difference from web development is that Unity UI exists in 3D space, even when creating 2D interfaces. Every UI element is a <a href="https://docs.unity3d.com/ScriptReference/GameObject.html" target="_blank">GameObject</a> with a <a href="https://docs.unity3d.com/ScriptReference/RectTransform.html" target="_blank">RectTransform</a> component that defines its position, size, rotation, and scale within its parent's coordinate system. Think of this like CSS positioning and flexbox, but with the added dimension of depth and the ability to rotate and scale UI elements in 3D space.</p>

                <div class="info-box">
                    <h4>DevOps Perspective: Canvas as Container Orchestration</h4>
                    <p>The Canvas component acts like a Docker container or Kubernetes namespaceâ€”it creates an isolated rendering environment where UI elements are batched and rendered together. Just as you might group related microservices in the same namespace for network efficiency, UI elements on the same Canvas are rendered in a single draw call for performance optimization.</p>
                </div>

                <h3>Canvas Render Modes</h3>
                
                <p>Unity provides three Canvas render modes, each serving different use cases in game development:</p>

                <div class="code-example">
                    <h4>Canvas Configuration Manager</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;

public class CanvasManager : <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank">MonoBehaviour</a>
{
    [Header("Canvas References")]
    public <a href="https://docs.unity3d.com/ScriptReference/Canvas.html" target="_blank">Canvas</a> screenSpaceOverlayCanvas;
    public <a href="https://docs.unity3d.com/ScriptReference/Canvas.html" target="_blank">Canvas</a> screenSpaceCameraCanvas; 
    public <a href="https://docs.unity3d.com/ScriptReference/Canvas.html" target="_blank">Canvas</a> worldSpaceCanvas;
    
    [Header("UI Cameras")]
    public Camera uiCamera;
    public Camera mainCamera;
    
    [Header("Configuration")]
    public bool adaptToScreenSize = true;
    public Vector2 referenceResolution = new Vector2(1920, 1080);
    
    void Start()
    {
        ConfigureCanvases();
        SetupResponsiveUI();
    }
    
    void ConfigureCanvases()
    {
        // Screen Space - Overlay: UI renders on top of everything
        // Use for: HUD, menus, notifications that should always be visible
        if (screenSpaceOverlayCanvas != null)
        {
            screenSpaceOverlayCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
            screenSpaceOverlayCanvas.sortingOrder = 100; // Render on top
            
            Debug.Log("Screen Space Overlay Canvas: Always renders on top, no camera needed");
        }
        
        // Screen Space - Camera: UI renders to a specific camera
        // Use for: UI that can be affected by camera effects, depth-dependent UI
        if (screenSpaceCameraCanvas != null &amp;&amp; uiCamera != null)
        {
            screenSpaceCameraCanvas.renderMode = RenderMode.ScreenSpaceCamera;
            screenSpaceCameraCanvas.worldCamera = uiCamera;
            screenSpaceCameraCanvas.planeDistance = 10f; // Distance from camera
            
            // Configure UI camera for crisp rendering
            uiCamera.clearFlags = CameraClearFlags.Depth;
            uiCamera.cullingMask = 1 &lt;&lt; LayerMask.NameToLayer("UI");
            uiCamera.orthographic = true;
            uiCamera.orthographicSize = 5f;
            
            Debug.Log("Screen Space Camera Canvas: Renders to UI camera, can use camera effects");
        }
        
        // World Space: UI exists as 3D object in world
        // Use for: In-game computer screens, floating health bars, 3D menus
        if (worldSpaceCanvas != null)
        {
            worldSpaceCanvas.renderMode = RenderMode.WorldSpace;
            worldSpaceCanvas.GetComponent&lt;RectTransform&gt;().sizeDelta = new Vector2(400, 300);
            
            // Make it render to all cameras
            worldSpaceCanvas.worldCamera = null; // Uses all cameras
            
            Debug.Log("World Space Canvas: 3D object in world, can be rotated and scaled");
        }
    }
    
    void SetupResponsiveUI()
    {
        if (!adaptToScreenSize) return;
        
        // Configure Canvas Scalers for responsive design
        ConfigureCanvasScaler(screenSpaceOverlayCanvas);
        ConfigureCanvasScaler(screenSpaceCameraCanvas);
    }
    
    void ConfigureCanvasScaler(Canvas canvas)
    {
        if (canvas == null) return;
        
        CanvasScaler scaler = canvas.GetComponent&lt;CanvasScaler&gt;();
        if (scaler == null)
        {
            scaler = canvas.gameObject.AddComponent&lt;CanvasScaler&gt;();
        }
        
        // Scale With Screen Size: Maintains aspect ratio across devices
        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
        scaler.referenceResolution = referenceResolution;
        scaler.screenMatchMode = CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;
        scaler.matchWidthOrHeight = 0.5f; // Balance between width and height matching
        
        Debug.Log($"Configured responsive scaling for {canvas.name}");
    }
    
    // Runtime canvas switching for different game states
    public void ShowGameplayUI()
    {
        SetCanvasVisibility(screenSpaceOverlayCanvas, true);
        SetCanvasVisibility(screenSpaceCameraCanvas, false);
        SetCanvasVisibility(worldSpaceCanvas, true);
    }
    
    public void ShowMenuUI()
    {
        SetCanvasVisibility(screenSpaceOverlayCanvas, true);
        SetCanvasVisibility(screenSpaceCameraCanvas, true);
        SetCanvasVisibility(worldSpaceCanvas, false);
    }
    
    void SetCanvasVisibility(Canvas canvas, bool visible)
    {
        if (canvas != null)
        {
            canvas.gameObject.SetActive(visible);
        }
    }
    
    // Performance monitoring for UI rendering
    void Update()
    {
        // Monitor canvas render statistics
        if (Input.GetKeyDown(KeyCode.F1))
        {
            LogCanvasStats();
        }
    }
    
    void LogCanvasStats()
    {
        Canvas[] allCanvases = FindObjectsOfType&lt;Canvas&gt;();
        
        foreach (Canvas canvas in allCanvases)
        {
            int uiElementCount = canvas.transform.childCount;
            GraphicRaycaster raycaster = canvas.GetComponent&lt;GraphicRaycaster&gt;();
            
            Debug.Log($"Canvas: {canvas.name}");
            Debug.Log($"  Render Mode: {canvas.renderMode}");
            Debug.Log($"  UI Elements: {uiElementCount}");
            Debug.Log($"  Raycaster Enabled: {raycaster != null &amp;&amp; raycaster.enabled}");
            Debug.Log($"  Sort Order: {canvas.sortingOrder}");
        }
    }
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>
            </section>

            <section>
                <h2>Responsive UI Design with RectTransform</h2>
                
                <p>The RectTransform component is Unity's solution for responsive UI layout, similar to CSS Grid and Flexbox combined. It provides anchoring, pivoting, and sizing controls that allow UI elements to adapt to different screen sizes and aspect ratios automatically.</p>

                <h3>Anchoring and Layout System</h3>

                <div class="code-example">
                    <h4>Responsive Layout Manager</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;

[System.Serializable]
public class ResponsiveUIElement
{
    public RectTransform element;
    public AnchorPresets anchorPreset;
    public Vector2 offsetMin;
    public Vector2 offsetMax;
    public Vector2 anchoredPosition;
    public Vector2 sizeDelta;
}

public enum AnchorPresets
{
    TopLeft, TopCenter, TopRight,
    MiddleLeft, MiddleCenter, MiddleRight,
    BottomLeft, BottomCenter, BottomRight,
    StretchTop, StretchMiddle, StretchBottom,
    StretchLeft, StretchCenter, StretchRight,
    StretchAll
}

public class ResponsiveLayoutManager : MonoBehaviour
{
    [Header("Layout Configuration")]
    public ResponsiveUIElement[] uiElements;
    public bool autoConfigureOnStart = true;
    public bool adaptToSafeArea = true;
    
    [Header("Screen Size Breakpoints")]
    public Vector2 mobileBreakpoint = new Vector2(800, 600);
    public Vector2 tabletBreakpoint = new Vector2(1280, 720);
    
    private Vector2 lastScreenSize;
    private RectTransform safeAreaRect;
    
    void Start()
    {
        if (adaptToSafeArea)
        {
            SetupSafeArea();
        }
        
        if (autoConfigureOnStart)
        {
            ConfigureResponsiveLayout();
        }
        
        lastScreenSize = new Vector2(Screen.width, Screen.height);
    }
    
    void Update()
    {
        // Detect screen size changes
        Vector2 currentScreenSize = new Vector2(Screen.width, Screen.height);
        
        if (currentScreenSize != lastScreenSize)
        {
            OnScreenSizeChanged();
            lastScreenSize = currentScreenSize;
        }
    }
    
    void SetupSafeArea()
    {
        // Create safe area container for mobile devices
        GameObject safeAreaObj = new GameObject("Safe Area");
        safeAreaObj.transform.SetParent(transform);
        
        safeAreaRect = safeAreaObj.AddComponent&lt;RectTransform&gt;();
        ApplySafeArea(safeAreaRect);
        
        // Move existing UI elements under safe area
        for (int i = transform.childCount - 1; i &gt;= 0; i--)
        {
            Transform child = transform.GetChild(i);
            if (child != safeAreaRect)
            {
                child.SetParent(safeAreaRect);
            }
        }
    }
    
    void ApplySafeArea(RectTransform rect)
    {
        Rect safeArea = Screen.safeArea;
        Vector2 screenSize = new Vector2(Screen.width, Screen.height);
        
        // Convert safe area from pixels to normalized coordinates
        Vector2 anchorMin = safeArea.position;
        Vector2 anchorMax = safeArea.position + safeArea.size;
        
        anchorMin.x /= screenSize.x;
        anchorMin.y /= screenSize.y;
        anchorMax.x /= screenSize.x;
        anchorMax.y /= screenSize.y;
        
        rect.anchorMin = anchorMin;
        rect.anchorMax = anchorMax;
        rect.offsetMin = Vector2.zero;
        rect.offsetMax = Vector2.zero;
        
        Debug.Log($"Applied safe area: {safeArea} to RectTransform");
    }
    
    void ConfigureResponsiveLayout()
    {
        ScreenSizeCategory category = GetScreenSizeCategory();
        
        foreach (ResponsiveUIElement uiElement in uiElements)
        {
            if (uiElement.element == null) continue;
            
            ConfigureElementForScreenSize(uiElement, category);
        }
        
        Debug.Log($"Configured UI layout for {category} screen size");
    }
    
    ScreenSizeCategory GetScreenSizeCategory()
    {
        Vector2 screenSize = new Vector2(Screen.width, Screen.height);
        
        if (screenSize.x &lt;= mobileBreakpoint.x || screenSize.y &lt;= mobileBreakpoint.y)
        {
            return ScreenSizeCategory.Mobile;
        }
        else if (screenSize.x &lt;= tabletBreakpoint.x || screenSize.y &lt;= tabletBreakpoint.y)
        {
            return ScreenSizeCategory.Tablet;
        }
        else
        {
            return ScreenSizeCategory.Desktop;
        }
    }
    
    void ConfigureElementForScreenSize(ResponsiveUIElement element, ScreenSizeCategory category)
    {
        // Apply anchor preset
        SetAnchorPreset(element.element, element.anchorPreset);
        
        // Scale UI elements based on screen size
        float scaleFactor = GetScaleFactorForCategory(category);
        Vector2 scaledSizeDelta = element.sizeDelta * scaleFactor;
        
        // Apply responsive properties
        element.element.offsetMin = element.offsetMin;
        element.element.offsetMax = element.offsetMax;
        element.element.anchoredPosition = element.anchoredPosition;
        element.element.sizeDelta = scaledSizeDelta;
    }
    
    float GetScaleFactorForCategory(ScreenSizeCategory category)
    {
        switch (category)
        {
            case ScreenSizeCategory.Mobile:
                return 0.8f; // Smaller UI elements for touch
            case ScreenSizeCategory.Tablet:
                return 1.0f; // Standard size
            case ScreenSizeCategory.Desktop:
                return 1.2f; // Larger for mouse precision
            default:
                return 1.0f;
        }
    }
    
    void SetAnchorPreset(RectTransform rectTransform, AnchorPresets preset)
    {
        switch (preset)
        {
            case AnchorPresets.TopLeft:
                rectTransform.anchorMin = new Vector2(0, 1);
                rectTransform.anchorMax = new Vector2(0, 1);
                break;
            case AnchorPresets.TopCenter:
                rectTransform.anchorMin = new Vector2(0.5f, 1);
                rectTransform.anchorMax = new Vector2(0.5f, 1);
                break;
            case AnchorPresets.TopRight:
                rectTransform.anchorMin = new Vector2(1, 1);
                rectTransform.anchorMax = new Vector2(1, 1);
                break;
            case AnchorPresets.MiddleLeft:
                rectTransform.anchorMin = new Vector2(0, 0.5f);
                rectTransform.anchorMax = new Vector2(0, 0.5f);
                break;
            case AnchorPresets.MiddleCenter:
                rectTransform.anchorMin = new Vector2(0.5f, 0.5f);
                rectTransform.anchorMax = new Vector2(0.5f, 0.5f);
                break;
            case AnchorPresets.MiddleRight:
                rectTransform.anchorMin = new Vector2(1, 0.5f);
                rectTransform.anchorMax = new Vector2(1, 0.5f);
                break;
            case AnchorPresets.BottomLeft:
                rectTransform.anchorMin = new Vector2(0, 0);
                rectTransform.anchorMax = new Vector2(0, 0);
                break;
            case AnchorPresets.BottomCenter:
                rectTransform.anchorMin = new Vector2(0.5f, 0);
                rectTransform.anchorMax = new Vector2(0.5f, 0);
                break;
            case AnchorPresets.BottomRight:
                rectTransform.anchorMin = new Vector2(1, 0);
                rectTransform.anchorMax = new Vector2(1, 0);
                break;
            case AnchorPresets.StretchAll:
                rectTransform.anchorMin = Vector2.zero;
                rectTransform.anchorMax = Vector2.one;
                break;
            // Add more presets as needed
        }
    }
    
    void OnScreenSizeChanged()
    {
        if (adaptToSafeArea &amp;&amp; safeAreaRect != null)
        {
            ApplySafeArea(safeAreaRect);
        }
        
        ConfigureResponsiveLayout();
        Debug.Log($"Screen size changed to {Screen.width}x{Screen.height}");
    }
    
    // Public API for runtime layout changes
    public void SetElementAnchor(string elementName, AnchorPresets preset)
    {
        foreach (ResponsiveUIElement element in uiElements)
        {
            if (element.element.name == elementName)
            {
                element.anchorPreset = preset;
                SetAnchorPreset(element.element, preset);
                break;
            }
        }
    }
    
    public void ReconfigureLayout()
    {
        ConfigureResponsiveLayout();
    }
}

public enum ScreenSizeCategory
{
    Mobile,
    Tablet,
    Desktop
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>

                <div class="warning-box">
                    <h4>Performance Note: Canvas Rebuilding</h4>
                    <p>Frequent changes to RectTransform properties can trigger expensive Canvas rebuilds. Group layout changes together and avoid modifying UI layouts every frame. Consider using object pooling for dynamic UI elements that change frequently.</p>
                </div>
            </section>

            <section>
                <h2>Event-Driven UI Programming</h2>
                
                <p>Unity's UI system uses an event-driven architecture similar to DOM events in web development. UI components like buttons, sliders, and input fields broadcast events that your scripts can listen to and respond to appropriately. This creates a clean separation between UI presentation and game logic.</p>

                <h3>UI Event System and Interactions</h3>

                <div class="code-example">
                    <h4>Comprehensive UI Event Manager</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using TMPro;

public class UIEventManager : MonoBehaviour
{
    [Header("UI References")]
    public Button[] gameButtons;
    public Slider[] gameSliders;
    public Toggle[] gameToggles;
    public TMP_InputField[] inputFields;
    public TMP_Dropdown[] dropdowns;
    
    [Header("Event Configuration")]
    public bool logUIEvents = true;
    public float buttonCooldown = 0.1f;
    
    // Event tracking
    private Dictionary&lt;Button, float&gt; buttonLastClickTimes = new Dictionary&lt;Button, float&gt;();
    private Dictionary&lt;string, System.Action&lt;object&gt;&gt; eventHandlers = new Dictionary&lt;string, System.Action&lt;object&gt;&gt;();
    
    void Start()
    {
        RegisterAllUIEvents();
        SetupCustomEventHandlers();
    }
    
    void RegisterAllUIEvents()
    {
        // Register button events
        foreach (Button button in gameButtons)
        {
            if (button != null)
            {
                RegisterButtonEvents(button);
            }
        }
        
        // Register slider events
        foreach (Slider slider in gameSliders)
        {
            if (slider != null)
            {
                RegisterSliderEvents(slider);
            }
        }
        
        // Register toggle events
        foreach (Toggle toggle in gameToggles)
        {
            if (toggle != null)
            {
                RegisterToggleEvents(toggle);
            }
        }
        
        // Register input field events
        foreach (TMP_InputField inputField in inputFields)
        {
            if (inputField != null)
            {
                RegisterInputFieldEvents(inputField);
            }
        }
        
        // Register dropdown events
        foreach (TMP_Dropdown dropdown in dropdowns)
        {
            if (dropdown != null)
            {
                RegisterDropdownEvents(dropdown);
            }
        }
        
        Debug.Log($"Registered events for {gameButtons.Length + gameSliders.Length + gameToggles.Length + inputFields.Length + dropdowns.Length} UI elements");
    }
    
    void RegisterButtonEvents(Button button)
    {
        // Primary click event
        button.onClick.AddListener(() =&gt; OnButtonClicked(button));
        
        // Add event trigger component for advanced interactions
        EventTrigger trigger = button.gameObject.GetComponent&lt;EventTrigger&gt;();
        if (trigger == null)
        {
            trigger = button.gameObject.AddComponent&lt;EventTrigger&gt;();
        }
        
        // Hover events
        AddEventTrigger(trigger, EventTriggerType.PointerEnter, (data) =&gt; OnButtonHoverEnter(button));
        AddEventTrigger(trigger, EventTriggerType.PointerExit, (data) =&gt; OnButtonHoverExit(button));
        
        // Press and release events
        AddEventTrigger(trigger, EventTriggerType.PointerDown, (data) =&gt; OnButtonPressed(button));
        AddEventTrigger(trigger, EventTriggerType.PointerUp, (data) =&gt; OnButtonReleased(button));
        
        // Initialize click time tracking
        buttonLastClickTimes[button] = 0f;
    }
    
    void RegisterSliderEvents(Slider slider)
    {
        // Value changed event
        slider.onValueChanged.AddListener((value) =&gt; OnSliderValueChanged(slider, value));
        
        // Drag events using EventTrigger
        EventTrigger trigger = slider.gameObject.GetComponent&lt;EventTrigger&gt;();
        if (trigger == null)
        {
            trigger = slider.gameObject.AddComponent&lt;EventTrigger&gt;();
        }
        
        AddEventTrigger(trigger, EventTriggerType.BeginDrag, (data) =&gt; OnSliderDragStart(slider));
        AddEventTrigger(trigger, EventTriggerType.EndDrag, (data) =&gt; OnSliderDragEnd(slider));
    }
    
    void RegisterToggleEvents(Toggle toggle)
    {
        toggle.onValueChanged.AddListener((isOn) =&gt; OnToggleChanged(toggle, isOn));
    }
    
    void RegisterInputFieldEvents(TMP_InputField inputField)
    {
        inputField.onValueChanged.AddListener((text) =&gt; OnInputFieldChanged(inputField, text));
        inputField.onEndEdit.AddListener((text) =&gt; OnInputFieldEndEdit(inputField, text));
        inputField.onSelect.AddListener((text) =&gt; OnInputFieldSelected(inputField));
        inputField.onDeselect.AddListener((text) =&gt; OnInputFieldDeselected(inputField));
    }
    
    void RegisterDropdownEvents(TMP_Dropdown dropdown)
    {
        dropdown.onValueChanged.AddListener((index) =&gt; OnDropdownValueChanged(dropdown, index));
    }
    
    void AddEventTrigger(EventTrigger trigger, EventTriggerType eventType, System.Action&lt;BaseEventData&gt; callback)
    {
        EventTrigger.Entry entry = new EventTrigger.Entry();
        entry.eventID = eventType;
        entry.callback.AddListener((data) =&gt; callback(data));
        trigger.triggers.Add(entry);
    }
    
    // Button event handlers
    void OnButtonClicked(Button button)
    {
        // Cooldown check to prevent spam clicking
        if (Time.time - buttonLastClickTimes[button] &lt; buttonCooldown) return;
        buttonLastClickTimes[button] = Time.time;
        
        if (logUIEvents)
        {
            Debug.Log($"Button clicked: {button.name}");
        }
        
        // Route to specific handlers based on button name
        string buttonName = button.name.ToLower();
        
        switch (buttonName)
        {
            case "play":
            case "playbutton":
                HandlePlayButton();
                break;
            case "pause":
            case "pausebutton":
                HandlePauseButton();
                break;
            case "settings":
            case "settingsbutton":
                HandleSettingsButton();
                break;
            case "quit":
            case "quitbutton":
                HandleQuitButton();
                break;
            default:
                HandleGenericButton(button);
                break;
        }
        
        // Fire custom event
        FireEvent($"button_{buttonName}_clicked", button);
    }
    
    void OnButtonHoverEnter(Button button)
    {
        if (logUIEvents)
        {
            Debug.Log($"Button hover enter: {button.name}");
        }
        
        // Visual feedback for hover
        ColorBlock colors = button.colors;
        colors.highlightedColor = Color.yellow;
        button.colors = colors;
    }
    
    void OnButtonHoverExit(Button button)
    {
        if (logUIEvents)
        {
            Debug.Log($"Button hover exit: {button.name}");
        }
    }
    
    void OnButtonPressed(Button button)
    {
        if (logUIEvents)
        {
            Debug.Log($"Button pressed: {button.name}");
        }
    }
    
    void OnButtonReleased(Button button)
    {
        if (logUIEvents)
        {
            Debug.Log($"Button released: {button.name}");
        }
    }
    
    // Slider event handlers
    void OnSliderValueChanged(Slider slider, float value)
    {
        if (logUIEvents)
        {
            Debug.Log($"Slider {slider.name} value changed to: {value:F2}");
        }
        
        string sliderName = slider.name.ToLower();
        
        switch (sliderName)
        {
            case "volume":
            case "volumeslider":
                HandleVolumeSlider(value);
                break;
            case "difficulty":
            case "difficultyslider":
                HandleDifficultySlider(value);
                break;
            default:
                HandleGenericSlider(slider, value);
                break;
        }
        
        FireEvent($"slider_{sliderName}_changed", value);
    }
    
    void OnSliderDragStart(Slider slider)
    {
        if (logUIEvents)
        {
            Debug.Log($"Slider drag started: {slider.name}");
        }
    }
    
    void OnSliderDragEnd(Slider slider)
    {
        if (logUIEvents)
        {
            Debug.Log($"Slider drag ended: {slider.name}");
        }
        
        FireEvent($"slider_{slider.name.ToLower()}_drag_end", slider.value);
    }
    
    // Toggle event handlers
    void OnToggleChanged(Toggle toggle, bool isOn)
    {
        if (logUIEvents)
        {
            Debug.Log($"Toggle {toggle.name} changed to: {isOn}");
        }
        
        string toggleName = toggle.name.ToLower();
        
        switch (toggleName)
        {
            case "sound":
            case "soundtoggle":
                HandleSoundToggle(isOn);
                break;
            case "fullscreen":
            case "fullscreentoggle":
                HandleFullscreenToggle(isOn);
                break;
            default:
                HandleGenericToggle(toggle, isOn);
                break;
        }
        
        FireEvent($"toggle_{toggleName}_changed", isOn);
    }
    
    // Input field event handlers
    void OnInputFieldChanged(TMP_InputField inputField, string text)
    {
        if (logUIEvents)
        {
            Debug.Log($"Input field {inputField.name} text changed: {text}");
        }
    }
    
    void OnInputFieldEndEdit(TMP_InputField inputField, string text)
    {
        if (logUIEvents)
        {
            Debug.Log($"Input field {inputField.name} editing ended: {text}");
        }
        
        string fieldName = inputField.name.ToLower();
        
        switch (fieldName)
        {
            case "username":
            case "playername":
                HandleUsernameInput(text);
                break;
            default:
                HandleGenericInputField(inputField, text);
                break;
        }
        
        FireEvent($"input_{fieldName}_submitted", text);
    }
    
    void OnInputFieldSelected(TMP_InputField inputField)
    {
        if (logUIEvents)
        {
            Debug.Log($"Input field selected: {inputField.name}");
        }
    }
    
    void OnInputFieldDeselected(TMP_InputField inputField)
    {
        if (logUIEvents)
        {
            Debug.Log($"Input field deselected: {inputField.name}");
        }
    }
    
    // Dropdown event handlers
    void OnDropdownValueChanged(TMP_Dropdown dropdown, int index)
    {
        string selectedOption = dropdown.options[index].text;
        
        if (logUIEvents)
        {
            Debug.Log($"Dropdown {dropdown.name} selection changed to: {selectedOption} (index {index})");
        }
        
        string dropdownName = dropdown.name.ToLower();
        
        switch (dropdownName)
        {
            case "resolution":
            case "resolutiondropdown":
                HandleResolutionDropdown(index, selectedOption);
                break;
            case "quality":
            case "qualitydropdown":
                HandleQualityDropdown(index, selectedOption);
                break;
            default:
                HandleGenericDropdown(dropdown, index, selectedOption);
                break;
        }
        
        FireEvent($"dropdown_{dropdownName}_changed", new { index, text = selectedOption });
    }
    
    // Specific UI handlers (implement based on your game's needs)
    void HandlePlayButton() 
    { 
        Debug.Log("Play button pressed - Starting game...");
        // Implement game start logic
    }
    
    void HandlePauseButton() 
    { 
        Debug.Log("Pause button pressed - Pausing game...");
        // Implement pause logic
    }
    
    void HandleSettingsButton() 
    { 
        Debug.Log("Settings button pressed - Opening settings...");
        // Implement settings menu logic
    }
    
    void HandleQuitButton() 
    { 
        Debug.Log("Quit button pressed - Exiting game...");
        Application.Quit();
    }
    
    void HandleVolumeSlider(float volume) 
    { 
        AudioListener.volume = volume;
        Debug.Log($"Volume set to: {volume:F2}");
    }
    
    void HandleDifficultySlider(float difficulty) 
    { 
        Debug.Log($"Difficulty set to: {difficulty:F2}");
        // Implement difficulty adjustment logic
    }
    
    void HandleSoundToggle(bool enabled) 
    { 
        AudioListener.volume = enabled ? 1f : 0f;
        Debug.Log($"Sound {(enabled ? "enabled" : "disabled")}");
    }
    
    void HandleFullscreenToggle(bool fullscreen) 
    { 
        Screen.fullScreen = fullscreen;
        Debug.Log($"Fullscreen {(fullscreen ? "enabled" : "disabled")}");
    }
    
    void HandleUsernameInput(string username) 
    { 
        PlayerPrefs.SetString("Username", username);
        Debug.Log($"Username set to: {username}");
    }
    
    void HandleResolutionDropdown(int index, string resolution) 
    { 
        Debug.Log($"Resolution changed to: {resolution}");
        // Implement resolution change logic
    }
    
    void HandleQualityDropdown(int index, string quality) 
    { 
        QualitySettings.SetQualityLevel(index);
        Debug.Log($"Quality level set to: {quality}");
    }
    
    // Generic handlers for extensibility
    void HandleGenericButton(Button button) 
    { 
        Debug.Log($"Generic button handler for: {button.name}");
    }
    
    void HandleGenericSlider(Slider slider, float value) 
    { 
        Debug.Log($"Generic slider handler for: {slider.name} = {value}");
    }
    
    void HandleGenericToggle(Toggle toggle, bool value) 
    { 
        Debug.Log($"Generic toggle handler for: {toggle.name} = {value}");
    }
    
    void HandleGenericInputField(TMP_InputField inputField, string text) 
    { 
        Debug.Log($"Generic input field handler for: {inputField.name} = {text}");
    }
    
    void HandleGenericDropdown(TMP_Dropdown dropdown, int index, string text) 
    { 
        Debug.Log($"Generic dropdown handler for: {dropdown.name} = {text}");
    }
    
    // Custom event system
    void SetupCustomEventHandlers()
    {
        // Register custom event handlers
        RegisterEventHandler("player_died", (data) =&gt; ShowGameOverScreen());
        RegisterEventHandler("level_completed", (data) =&gt; ShowLevelCompleteScreen());
        RegisterEventHandler("score_updated", (data) =&gt; UpdateScoreDisplay((int)data));
    }
    
    public void RegisterEventHandler(string eventName, System.Action&lt;object&gt; handler)
    {
        if (eventHandlers.ContainsKey(eventName))
        {
            eventHandlers[eventName] += handler;
        }
        else
        {
            eventHandlers[eventName] = handler;
        }
    }
    
    public void FireEvent(string eventName, object data = null)
    {
        if (eventHandlers.ContainsKey(eventName))
        {
            eventHandlers[eventName]?.Invoke(data);
        }
    }
    
    // UI screen management
    void ShowGameOverScreen() 
    { 
        Debug.Log("Showing game over screen");
        // Implement game over UI logic
    }
    
    void ShowLevelCompleteScreen() 
    { 
        Debug.Log("Showing level complete screen");
        // Implement level complete UI logic
    }
    
    void UpdateScoreDisplay(int score) 
    { 
        Debug.Log($"Updating score display to: {score}");
        // Implement score UI update logic
    }
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>
            </section>

            <section>
                <h2>Advanced UI Components and Custom Controls</h2>
                
                <p>While Unity provides standard UI components like buttons and sliders, many games require specialized interface elements. Creating custom UI components follows the same patterns as building reusable components in modern web frameworksâ€”you encapsulate behavior, expose configuration options, and provide clear APIs for interaction.</p>

                <h3>Building Custom UI Components</h3>

                <div class="code-example">
                    <h4>Custom Progress Bar Component</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;

[System.Serializable]
public class ProgressBarStyle
{
    public Color backgroundColor = Color.gray;
    public Color fillColor = Color.green;
    public Color textColor = Color.white;
    public bool showPercentage = true;
    public bool showCurrentValue = false;
    public bool animateChanges = true;
    public float animationSpeed = 2f;
}

public class CustomProgressBar : MonoBehaviour
{
    [Header("Progress Configuration")]
    [SerializeField] private float minValue = 0f;
    [SerializeField] private float maxValue = 100f;
    [SerializeField] private float currentValue = 0f;
    
    [Header("UI References")]
    public Image backgroundImage;
    public Image fillImage;
    public TextMeshProUGUI displayText;
    
    [Header("Styling")]
    public ProgressBarStyle style;
    
    [Header("Events")]
    public UnityEngine.Events.UnityEvent&lt;float&gt; OnValueChanged;
    public UnityEngine.Events.UnityEvent OnProgressComplete;
    public UnityEngine.Events.UnityEvent OnProgressEmpty;
    
    // Private state
    private float targetValue;
    private bool isAnimating = false;
    private Coroutine animationCoroutine;
    
    // Public properties
    public float Value
    {
        get { return currentValue; }
        set { SetValue(value, style.animateChanges); }
    }
    
    public float NormalizedValue
    {
        get { return Mathf.InverseLerp(minValue, maxValue, currentValue); }
    }
    
    public bool IsComplete
    {
        get { return currentValue &gt;= maxValue; }
    }
    
    public bool IsEmpty
    {
        get { return currentValue &lt;= minValue; }
    }
    
    void Start()
    {
        InitializeProgressBar();
        UpdateDisplay();
    }
    
    void InitializeProgressBar()
    {
        targetValue = currentValue;
        
        // Apply styling
        ApplyStyle();
        
        // Validate references
        if (backgroundImage == null)
        {
            Debug.LogWarning($"Progress Bar '{name}' missing background image reference");
        }
        
        if (fillImage == null)
        {
            Debug.LogWarning($"Progress Bar '{name}' missing fill image reference");
        }
        
        // Initialize fill image
        if (fillImage != null)
        {
            fillImage.type = Image.Type.Filled;
            fillImage.fillMethod = Image.FillMethod.Horizontal;
        }
    }
    
    void ApplyStyle()
    {
        if (backgroundImage != null)
        {
            backgroundImage.color = style.backgroundColor;
        }
        
        if (fillImage != null)
        {
            fillImage.color = style.fillColor;
        }
        
        if (displayText != null)
        {
            displayText.color = style.textColor;
        }
    }
    
    public void SetValue(float newValue, bool animate = true)
    {
        // Clamp value to valid range
        newValue = Mathf.Clamp(newValue, minValue, maxValue);
        
        // Check if value actually changed
        if (Mathf.Approximately(newValue, targetValue))
        {
            return;
        }
        
        float oldValue = currentValue;
        targetValue = newValue;
        
        if (animate &amp;&amp; style.animateChanges)
        {
            StartAnimation();
        }
        else
        {
            currentValue = newValue;
            UpdateDisplay();
            FireEvents(oldValue, newValue);
        }
    }
    
    public void SetMinMax(float min, float max)
    {
        minValue = min;
        maxValue = max;
        currentValue = Mathf.Clamp(currentValue, minValue, maxValue);
        targetValue = currentValue;
        UpdateDisplay();
    }
    
    public void AddValue(float amount)
    {
        SetValue(currentValue + amount);
    }
    
    public void SubtractValue(float amount)
    {
        SetValue(currentValue - amount);
    }
    
    public void SetToMax()
    {
        SetValue(maxValue);
    }
    
    public void SetToMin()
    {
        SetValue(minValue);
    }
    
    void StartAnimation()
    {
        if (animationCoroutine != null)
        {
            StopCoroutine(animationCoroutine);
        }
        
        animationCoroutine = StartCoroutine(AnimateToTarget());
    }
    
    IEnumerator AnimateToTarget()
    {
        isAnimating = true;
        float startValue = currentValue;
        float elapsedTime = 0f;
        float animationDuration = Mathf.Abs(targetValue - startValue) / (maxValue - minValue) / style.animationSpeed;
        
        while (elapsedTime &lt; animationDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = elapsedTime / animationDuration;
            
            // Use easing for smooth animation
            t = EaseInOutCubic(t);
            
            float oldValue = currentValue;
            currentValue = Mathf.Lerp(startValue, targetValue, t);
            UpdateDisplay();
            
            // Fire events during animation
            if (!Mathf.Approximately(oldValue, currentValue))
            {
                OnValueChanged?.Invoke(currentValue);
            }
            
            yield return null;
        }
        
        // Ensure we end exactly at target
        float finalOldValue = currentValue;
        currentValue = targetValue;
        UpdateDisplay();
        
        isAnimating = false;
        FireEvents(finalOldValue, currentValue);
    }
    
    float EaseInOutCubic(float t)
    {
        return t &lt; 0.5f ? 4f * t * t * t : 1f - Mathf.Pow(-2f * t + 2f, 3f) / 2f;
    }
    
    void UpdateDisplay()
    {
        UpdateFillAmount();
        UpdateText();
    }
    
    void UpdateFillAmount()
    {
        if (fillImage == null) return;
        
        float normalizedValue = NormalizedValue;
        fillImage.fillAmount = normalizedValue;
    }
    
    void UpdateText()
    {
        if (displayText == null) return;
        
        string text = "";
        
        if (style.showPercentage)
        {
            float percentage = NormalizedValue * 100f;
            text += $"{percentage:F0}%";
        }
        
        if (style.showCurrentValue)
        {
            if (text.Length &gt; 0) text += " ";
            text += $"{currentValue:F0}/{maxValue:F0}";
        }
        
        displayText.text = text;
    }
    
    void FireEvents(float oldValue, float newValue)
    {
        OnValueChanged?.Invoke(newValue);
        
        // Check for completion/empty state
        bool wasComplete = oldValue &gt;= maxValue;
        bool isNowComplete = newValue &gt;= maxValue;
        bool wasEmpty = oldValue &lt;= minValue;
        bool isNowEmpty = newValue &lt;= minValue;
        
        if (!wasComplete &amp;&amp; isNowComplete)
        {
            OnProgressComplete?.Invoke();
        }
        
        if (!wasEmpty &amp;&amp; isNowEmpty)
        {
            OnProgressEmpty?.Invoke();
        }
    }
    
    // Color transition methods
    public void SetFillColor(Color newColor, bool animate = true)
    {
        if (fillImage == null) return;
        
        if (animate)
        {
            StartCoroutine(AnimateColorTransition(fillImage, newColor, 0.5f));
        }
        else
        {
            fillImage.color = newColor;
            style.fillColor = newColor;
        }
    }
    
    IEnumerator AnimateColorTransition(Image image, Color targetColor, float duration)
    {
        Color startColor = image.color;
        float elapsedTime = 0f;
        
        while (elapsedTime &lt; duration)
        {
            elapsedTime += Time.deltaTime;
            float t = elapsedTime / duration;
            image.color = Color.Lerp(startColor, targetColor, t);
            yield return null;
        }
        
        image.color = targetColor;
    }
    
    // Editor helper methods
    #if UNITY_EDITOR
    void OnValidate()
    {
        if (Application.isPlaying)
        {
            currentValue = Mathf.Clamp(currentValue, minValue, maxValue);
            targetValue = currentValue;
            UpdateDisplay();
        }
    }
    #endif
    
    // Debug visualization
    void OnDrawGizmosSelected()
    {
        if (!Application.isPlaying) return;
        
        Gizmos.color = Color.yellow;
        Vector3 position = transform.position;
        UnityEditor.Handles.Label(position + Vector3.up * 50f, 
            $"Progress: {currentValue:F1}/{maxValue:F1} ({NormalizedValue:P0})");
    }
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>

                <h3>Inventory and Item Slot System</h3>

                <div class="code-example">
                    <h4>Drag-and-Drop Inventory System</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using TMPro;

[System.Serializable]
public class InventoryItem
{
    public string itemId;
    public string displayName;
    public Sprite icon;
    public int quantity;
    public int maxStackSize;
    public string description;
    
    public bool CanStackWith(InventoryItem other)
    {
        return other != null &amp;&amp; other.itemId == itemId &amp;&amp; quantity + other.quantity &lt;= maxStackSize;
    }
}

public class InventorySlot : MonoBehaviour, IPointerClickHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler
{
    [Header("UI References")]
    public Image iconImage;
    public TextMeshProUGUI quantityText;
    public Image backgroundImage;
    public Button slotButton;
    
    [Header("Visual Feedback")]
    public Color normalColor = Color.white;
    public Color highlightColor = Color.yellow;
    public Color occupiedColor = Color.green;
    public Color invalidDropColor = Color.red;
    
    [Header("Configuration")]
    public bool acceptsAnyItem = true;
    public string[] acceptedItemTypes;
    
    // Events
    public System.Action&lt;InventorySlot&gt; OnSlotClicked;
    public System.Action&lt;InventorySlot, InventoryItem&gt; OnItemPlaced;
    public System.Action&lt;InventorySlot, InventoryItem&gt; OnItemRemoved;
    
    // State
    private InventoryItem currentItem;
    private bool isDragging = false;
    private Vector3 originalPosition;
    private Transform originalParent;
    private CanvasGroup canvasGroup;
    
    // Static references for drag operations
    private static InventorySlot draggedSlot;
    private static GameObject draggedItemVisual;
    
    // Properties
    public bool IsOccupied =&gt; currentItem != null;
    public InventoryItem Item =&gt; currentItem;
    public bool CanAcceptItem(InventoryItem item) =&gt; acceptsAnyItem || System.Array.Exists(acceptedItemTypes, type =&gt; type == item.itemId);
    
    void Awake()
    {
        canvasGroup = GetComponent&lt;CanvasGroup&gt;();
        if (canvasGroup == null)
        {
            canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();
        }
        
        SetupSlotAppearance();
    }
    
    void SetupSlotAppearance()
    {
        if (backgroundImage != null)
        {
            backgroundImage.color = normalColor;
        }
        
        if (iconImage != null)
        {
            iconImage.enabled = false;
        }
        
        if (quantityText != null)
        {
            quantityText.text = "";
        }
    }
    
    public void SetItem(InventoryItem item)
    {
        if (item == null)
        {
            ClearSlot();
            return;
        }
        
        InventoryItem oldItem = currentItem;
        currentItem = item;
        
        UpdateSlotDisplay();
        
        // Fire events
        if (oldItem == null)
        {
            OnItemPlaced?.Invoke(this, item);
        }
    }
    
    public void ClearSlot()
    {
        InventoryItem removedItem = currentItem;
        currentItem = null;
        
        UpdateSlotDisplay();
        
        if (removedItem != null)
        {
            OnItemRemoved?.Invoke(this, removedItem);
        }
    }
    
    public bool TryAddItem(InventoryItem item)
    {
        if (!CanAcceptItem(item))
        {
            return false;
        }
        
        // Try stacking if slot is occupied
        if (IsOccupied)
        {
            if (currentItem.CanStackWith(item))
            {
                int addedQuantity = Mathf.Min(item.quantity, currentItem.maxStackSize - currentItem.quantity);
                currentItem.quantity += addedQuantity;
                item.quantity -= addedQuantity;
                
                UpdateSlotDisplay();
                return item.quantity == 0; // Return true if all items were stacked
            }
            return false; // Can't stack
        }
        else
        {
            SetItem(item);
            return true;
        }
    }
    
    public InventoryItem TakeItem(int quantity = -1)
    {
        if (!IsOccupied) return null;
        
        if (quantity == -1 || quantity &gt;= currentItem.quantity)
        {
            InventoryItem takenItem = currentItem;
            ClearSlot();
            return takenItem;
        }
        else
        {
            // Take partial quantity
            InventoryItem partialItem = new InventoryItem
            {
                itemId = currentItem.itemId,
                displayName = currentItem.displayName,
                icon = currentItem.icon,
                quantity = quantity,
                maxStackSize = currentItem.maxStackSize,
                description = currentItem.description
            };
            
            currentItem.quantity -= quantity;
            UpdateSlotDisplay();
            
            return partialItem;
        }
    }
    
    void UpdateSlotDisplay()
    {
        if (IsOccupied)
        {
            // Show item icon and quantity
            if (iconImage != null)
            {
                iconImage.sprite = currentItem.icon;
                iconImage.enabled = true;
            }
            
            if (quantityText != null)
            {
                quantityText.text = currentItem.quantity &gt; 1 ? currentItem.quantity.ToString() : "";
            }
            
            if (backgroundImage != null)
            {
                backgroundImage.color = occupiedColor;
            }
        }
        else
        {
            // Clear display
            if (iconImage != null)
            {
                iconImage.enabled = false;
            }
            
            if (quantityText != null)
            {
                quantityText.text = "";
            }
            
            if (backgroundImage != null)
            {
                backgroundImage.color = normalColor;
            }
        }
    }
    
    // Interface implementations for drag and drop
    public void OnPointerClick(PointerEventData eventData)
    {
        OnSlotClicked?.Invoke(this);
        
        // Handle right-click for quick actions
        if (eventData.button == PointerEventData.InputButton.Right &amp;&amp; IsOccupied)
        {
            HandleRightClick();
        }
    }
    
    public void OnBeginDrag(PointerEventData eventData)
    {
        if (!IsOccupied) return;
        
        isDragging = true;
        draggedSlot = this;
        
        // Create visual for dragged item
        CreateDragVisual();
        
        // Reduce slot opacity during drag
        canvasGroup.alpha = 0.6f;
        canvasGroup.blocksRaycasts = false;
        
        originalPosition = transform.position;
        originalParent = transform.parent;
    }
    
    public void OnDrag(PointerEventData eventData)
    {
        if (isDragging &amp;&amp; draggedItemVisual != null)
        {
            draggedItemVisual.transform.position = eventData.position;
        }
    }
    
    public void OnEndDrag(PointerEventData eventData)
    {
        if (!isDragging) return;
        
        isDragging = false;
        draggedSlot = null;
        
        // Restore appearance
        canvasGroup.alpha = 1f;
        canvasGroup.blocksRaycasts = true;
        
        // Clean up drag visual
        if (draggedItemVisual != null)
        {
            Destroy(draggedItemVisual);
            draggedItemVisual = null;
        }
    }
    
    public void OnDrop(PointerEventData eventData)
    {
        if (draggedSlot == null || draggedSlot == this) return;
        
        // Attempt to transfer item
        bool success = TryTransferFrom(draggedSlot);
        
        if (success)
        {
            SetDropHighlight(false);
        }
        else
        {
            // Show invalid drop feedback
            StartCoroutine(ShowInvalidDropFeedback());
        }
    }
    
    bool TryTransferFrom(InventorySlot sourceSlot)
    {
        if (sourceSlot == null || !sourceSlot.IsOccupied) return false;
        
        InventoryItem itemToTransfer = sourceSlot.Item;
        
        // Check if we can accept this item
        if (!CanAcceptItem(itemToTransfer))
        {
            return false;
        }
        
        // Handle different transfer scenarios
        if (!IsOccupied)
        {
            // Empty slot - take entire item
            InventoryItem transferredItem = sourceSlot.TakeItem();
            SetItem(transferredItem);
            return true;
        }
        else if (currentItem.CanStackWith(itemToTransfer))
        {
            // Stack items
            int spaceAvailable = currentItem.maxStackSize - currentItem.quantity;
            int transferQuantity = Mathf.Min(itemToTransfer.quantity, spaceAvailable);
            
            currentItem.quantity += transferQuantity;
            
            if (transferQuantity == itemToTransfer.quantity)
            {
                sourceSlot.ClearSlot();
            }
            else
            {
                itemToTransfer.quantity -= transferQuantity;
                sourceSlot.UpdateSlotDisplay();
            }
            
            UpdateSlotDisplay();
            return true;
        }
        else
        {
            // Swap items
            InventoryItem tempItem = currentItem;
            SetItem(sourceSlot.TakeItem());
            sourceSlot.SetItem(tempItem);
            return true;
        }
    }
    
    void CreateDragVisual()
    {
        if (!IsOccupied) return;
        
        // Create a visual copy of the item for dragging
        GameObject dragVisualObj = new GameObject("DragVisual");
        draggedItemVisual = dragVisualObj;
        
        // Set up as UI element
        dragVisualObj.transform.SetParent(GetComponentInParent&lt;Canvas&gt;().transform);
        dragVisualObj.transform.SetAsLastSibling(); // Render on top
        
        // Add Image component
        Image dragImage = dragVisualObj.AddComponent&lt;Image&gt;();
        dragImage.sprite = currentItem.icon;
        dragImage.raycastTarget = false;
        
        // Add CanvasGroup for transparency
        CanvasGroup dragCanvasGroup = dragVisualObj.AddComponent&lt;CanvasGroup&gt;();
        dragCanvasGroup.alpha = 0.8f;
        dragCanvasGroup.blocksRaycasts = false;
        
        // Set size to match original
        RectTransform dragRect = dragVisualObj.GetComponent&lt;RectTransform&gt;();
        RectTransform iconRect = iconImage.GetComponent&lt;RectTransform&gt;();
        dragRect.sizeDelta = iconRect.sizeDelta;
    }
    
    void HandleRightClick()
    {
        // Implement context menu or quick actions
        Debug.Log($"Right-clicked on {currentItem.displayName}");
        // Could show tooltip, context menu, or perform quick action
    }
    
    void SetDropHighlight(bool highlight)
    {
        if (backgroundImage == null) return;
        
        Color targetColor = highlight ? highlightColor : (IsOccupied ? occupiedColor : normalColor);
        backgroundImage.color = targetColor;
    }
    
    System.Collections.IEnumerator ShowInvalidDropFeedback()
    {
        Color originalColor = backgroundImage.color;
        backgroundImage.color = invalidDropColor;
        
        yield return new WaitForSeconds(0.2f);
        
        backgroundImage.color = originalColor;
    }
    
    // Mouse enter/exit for highlighting
    void OnMouseEnter()
    {
        if (!isDragging &amp;&amp; draggedSlot != null)
        {
            // Show whether this slot can accept the dragged item
            bool canAccept = draggedSlot.IsOccupied &amp;&amp; CanAcceptItem(draggedSlot.Item);
            SetDropHighlight(canAccept);
        }
    }
    
    void OnMouseExit()
    {
        SetDropHighlight(false);
    }
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>
            </section>

            <section>
                <h2>UI Animation and Visual Feedback</h2>
                
                <p>Effective UI animation provides visual feedback that helps users understand state changes and system responses. Unity's animation system, combined with code-driven tweening, allows you to create smooth, responsive interfaces that feel polished and professional.</p>

                <h3>UI Animation Manager</h3>

                <div class="code-example">
                    <h4>Comprehensive UI Animation System</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;
using System.Collections.Generic;

public class UIAnimationManager : MonoBehaviour
{
    [Header("Animation Presets")]
    public AnimationSettings fadeSettings;
    public AnimationSettings scaleSettings;
    public AnimationSettings slideSettings;
    public AnimationSettings bounceSettings;
    
    [Header("Global Settings")]
    public bool useUnscaledTime = true;
    public float globalAnimationSpeed = 1f;
    
    // Active animations tracking
    private Dictionary&lt;GameObject, List&lt;Coroutine&gt;&gt; activeAnimations = new Dictionary&lt;GameObject, List&lt;Coroutine&gt;&gt;();
    
    void Start()
    {
        InitializeDefaultSettings();
    }
    
    void InitializeDefaultSettings()
    {
        // Set up default animation settings if not configured
        if (fadeSettings == null) fadeSettings = new AnimationSettings { duration = 0.3f, easing = EasingType.EaseOut };
        if (scaleSettings == null) scaleSettings = new AnimationSettings { duration = 0.2f, easing = EasingType.EaseOutBack };
        if (slideSettings == null) slideSettings = new AnimationSettings { duration = 0.5f, easing = EasingType.EaseOut };
        if (bounceSettings == null) bounceSettings = new AnimationSettings { duration = 0.6f, easing = EasingType.EaseOutBounce };
    }
    
    // Fade animations
    public void FadeIn(CanvasGroup canvasGroup, float targetAlpha = 1f, AnimationSettings settings = null)
    {
        if (canvasGroup == null) return;
        
        settings = settings ?? fadeSettings;
        StopAnimations(canvasGroup.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateFade(canvasGroup, targetAlpha, settings));
        TrackAnimation(canvasGroup.gameObject, animation);
    }
    
    public void FadeOut(CanvasGroup canvasGroup, AnimationSettings settings = null)
    {
        FadeIn(canvasGroup, 0f, settings);
    }
    
    public void FadeInImage(Image image, float targetAlpha = 1f, AnimationSettings settings = null)
    {
        if (image == null) return;
        
        settings = settings ?? fadeSettings;
        StopAnimations(image.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateImageFade(image, targetAlpha, settings));
        TrackAnimation(image.gameObject, animation);
    }
    
    public void FadeInText(TextMeshProUGUI text, float targetAlpha = 1f, AnimationSettings settings = null)
    {
        if (text == null) return;
        
        settings = settings ?? fadeSettings;
        StopAnimations(text.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateTextFade(text, targetAlpha, settings));
        TrackAnimation(text.gameObject, animation);
    }
    
    // Scale animations
    public void ScaleIn(Transform target, Vector3 targetScale, AnimationSettings settings = null)
    {
        if (target == null) return;
        
        settings = settings ?? scaleSettings;
        StopAnimations(target.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateScale(target, targetScale, settings));
        TrackAnimation(target.gameObject, animation);
    }
    
    public void ScaleIn(Transform target, AnimationSettings settings = null)
    {
        ScaleIn(target, Vector3.one, settings);
    }
    
    public void ScaleOut(Transform target, AnimationSettings settings = null)
    {
        ScaleIn(target, Vector3.zero, settings);
    }
    
    public void PulseScale(Transform target, float pulseScale = 1.1f, AnimationSettings settings = null)
    {
        if (target == null) return;
        
        settings = settings ?? bounceSettings;
        StopAnimations(target.gameObject);
        
        Coroutine animation = StartCoroutine(AnimatePulse(target, pulseScale, settings));
        TrackAnimation(target.gameObject, animation);
    }
    
    // Slide animations
    public void SlideIn(RectTransform target, Vector2 fromPosition, Vector2 toPosition, AnimationSettings settings = null)
    {
        if (target == null) return;
        
        settings = settings ?? slideSettings;
        StopAnimations(target.gameObject);
        
        target.anchoredPosition = fromPosition;
        
        Coroutine animation = StartCoroutine(AnimatePosition(target, toPosition, settings));
        TrackAnimation(target.gameObject, animation);
    }
    
    public void SlideInFromDirection(RectTransform target, SlideDirection direction, float distance = 500f, AnimationSettings settings = null)
    {
        if (target == null) return;
        
        Vector2 currentPosition = target.anchoredPosition;
        Vector2 startPosition = currentPosition;
        
        switch (direction)
        {
            case SlideDirection.Left:
                startPosition.x -= distance;
                break;
            case SlideDirection.Right:
                startPosition.x += distance;
                break;
            case SlideDirection.Up:
                startPosition.y += distance;
                break;
            case SlideDirection.Down:
                startPosition.y -= distance;
                break;
        }
        
        SlideIn(target, startPosition, currentPosition, settings);
    }
    
    // Color animations
    public void AnimateColor(Image image, Color targetColor, AnimationSettings settings = null)
    {
        if (image == null) return;
        
        settings = settings ?? fadeSettings;
        StopAnimations(image.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateImageColor(image, targetColor, settings));
        TrackAnimation(image.gameObject, animation);
    }
    
    public void AnimateTextColor(TextMeshProUGUI text, Color targetColor, AnimationSettings settings = null)
    {
        if (text == null) return;
        
        settings = settings ?? fadeSettings;
        StopAnimations(text.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateTextColor(text, targetColor, settings));
        TrackAnimation(text.gameObject, animation);
    }
    
    // Number counting animation
    public void AnimateNumber(TextMeshProUGUI text, float startValue, float endValue, string format = "F0", AnimationSettings settings = null)
    {
        if (text == null) return;
        
        settings = settings ?? fadeSettings;
        StopAnimations(text.gameObject);
        
        Coroutine animation = StartCoroutine(AnimateNumberCount(text, startValue, endValue, format, settings));
        TrackAnimation(text.gameObject, animation);
    }
    
    // Sequence and compound animations
    public void ShowPanel(GameObject panel, AnimationSettings scaleSettings = null, AnimationSettings fadeSettings = null)
    {
        if (panel == null) return;
        
        panel.SetActive(true);
        
        Transform panelTransform = panel.transform;
        CanvasGroup canvasGroup = panel.GetComponent&lt;CanvasGroup&gt;();
        
        if (canvasGroup == null)
        {
            canvasGroup = panel.AddComponent&lt;CanvasGroup&gt;();
        }
        
        // Start both animations simultaneously
        panelTransform.localScale = Vector3.zero;
        canvasGroup.alpha = 0f;
        
        ScaleIn(panelTransform, Vector3.one, scaleSettings ?? this.scaleSettings);
        FadeIn(canvasGroup, 1f, fadeSettings ?? this.fadeSettings);
    }
    
    public void HidePanel(GameObject panel, System.Action onComplete = null, AnimationSettings scaleSettings = null, AnimationSettings fadeSettings = null)
    {
        if (panel == null) return;
        
        StartCoroutine(HidePanelCoroutine(panel, onComplete, scaleSettings, fadeSettings));
    }
    
    // Core animation coroutines
    IEnumerator AnimateFade(CanvasGroup canvasGroup, float targetAlpha, AnimationSettings settings)
    {
        float startAlpha = canvasGroup.alpha;
        yield return AnimateFloat(startAlpha, targetAlpha, settings.duration, (value) =&gt; canvasGroup.alpha = value, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimateImageFade(Image image, float targetAlpha, AnimationSettings settings)
    {
        Color startColor = image.color;
        Color targetColor = new Color(startColor.r, startColor.g, startColor.b, targetAlpha);
        
        yield return AnimateColor(startColor, targetColor, settings.duration, (color) =&gt; image.color = color, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimateTextFade(TextMeshProUGUI text, float targetAlpha, AnimationSettings settings)
    {
        Color startColor = text.color;
        Color targetColor = new Color(startColor.r, startColor.g, startColor.b, targetAlpha);
        
        yield return AnimateColor(startColor, targetColor, settings.duration, (color) =&gt; text.color = color, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimateScale(Transform target, Vector3 targetScale, AnimationSettings settings)
    {
        Vector3 startScale = target.localScale;
        yield return AnimateVector3(startScale, targetScale, settings.duration, (scale) =&gt; target.localScale = scale, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimatePosition(RectTransform target, Vector2 targetPosition, AnimationSettings settings)
    {
        Vector2 startPosition = target.anchoredPosition;
        yield return AnimateVector2(startPosition, targetPosition, settings.duration, (pos) =&gt; target.anchoredPosition = pos, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimatePulse(Transform target, float pulseScale, AnimationSettings settings)
    {
        Vector3 originalScale = target.localScale;
        Vector3 pulseTargetScale = originalScale * pulseScale;
        
        // Scale up
        yield return AnimateVector3(originalScale, pulseTargetScale, settings.duration * 0.5f, (scale) =&gt; target.localScale = scale, EasingType.EaseOut);
        
        // Scale back down
        yield return AnimateVector3(pulseTargetScale, originalScale, settings.duration * 0.5f, (scale) =&gt; target.localScale = scale, EasingType.EaseIn, settings.onComplete);
    }
    
    IEnumerator AnimateImageColor(Image image, Color targetColor, AnimationSettings settings)
    {
        Color startColor = image.color;
        yield return AnimateColor(startColor, targetColor, settings.duration, (color) =&gt; image.color = color, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimateTextColor(TextMeshProUGUI text, Color targetColor, AnimationSettings settings)
    {
        Color startColor = text.color;
        yield return AnimateColor(startColor, targetColor, settings.duration, (color) =&gt; text.color = color, settings.easing, settings.onComplete);
    }
    
    IEnumerator AnimateNumberCount(TextMeshProUGUI text, float startValue, float endValue, string format, AnimationSettings settings)
    {
        yield return AnimateFloat(startValue, endValue, settings.duration, (value) =&gt; text.text = value.ToString(format), settings.easing, settings.onComplete);
    }
    
    IEnumerator HidePanelCoroutine(GameObject panel, System.Action onComplete, AnimationSettings scaleSettings, AnimationSettings fadeSettings)
    {
        Transform panelTransform = panel.transform;
        CanvasGroup canvasGroup = panel.GetComponent&lt;CanvasGroup&gt;();
        
        if (canvasGroup == null)
        {
            canvasGroup = panel.AddComponent&lt;CanvasGroup&gt;();
        }
        
        // Start both animations
        ScaleOut(panelTransform, scaleSettings ?? this.scaleSettings);
        FadeOut(canvasGroup, fadeSettings ?? this.fadeSettings);
        
        // Wait for the longer animation to complete
        float waitTime = Mathf.Max(
            (scaleSettings ?? this.scaleSettings).duration,
            (fadeSettings ?? this.fadeSettings).duration
        );
        
        yield return new WaitForSeconds(waitTime);
        
        panel.SetActive(false);
        onComplete?.Invoke();
    }
    
    // Base animation methods
    IEnumerator AnimateFloat(float startValue, float endValue, float duration, System.Action&lt;float&gt; updateCallback, EasingType easing, System.Action onComplete = null)
    {
        float elapsedTime = 0f;
        
        while (elapsedTime &lt; duration)
        {
            elapsedTime += GetDeltaTime();
            float t = Mathf.Clamp01(elapsedTime / duration);
            float easedT = ApplyEasing(t, easing);
            float currentValue = Mathf.Lerp(startValue, endValue, easedT);
            
            updateCallback(currentValue);
            yield return null;
        }
        
        updateCallback(endValue);
        onComplete?.Invoke();
    }
    
    IEnumerator AnimateVector2(Vector2 startValue, Vector2 endValue, float duration, System.Action&lt;Vector2&gt; updateCallback, EasingType easing, System.Action onComplete = null)
    {
        float elapsedTime = 0f;
        
        while (elapsedTime &lt; duration)
        {
            elapsedTime += GetDeltaTime();
            float t = Mathf.Clamp01(elapsedTime / duration);
            float easedT = ApplyEasing(t, easing);
            Vector2 currentValue = Vector2.Lerp(startValue, endValue, easedT);
            
            updateCallback(currentValue);
            yield return null;
        }
        
        updateCallback(endValue);
        onComplete?.Invoke();
    }
    
    IEnumerator AnimateVector3(Vector3 startValue, Vector3 endValue, float duration, System.Action&lt;Vector3&gt; updateCallback, EasingType easing, System.Action onComplete = null)
    {
        float elapsedTime = 0f;
        
        while (elapsedTime &lt; duration)
        {
            elapsedTime += GetDeltaTime();
            float t = Mathf.Clamp01(elapsedTime / duration);
            float easedT = ApplyEasing(t, easing);
            Vector3 currentValue = Vector3.Lerp(startValue, endValue, easedT);
            
            updateCallback(currentValue);
            yield return null;
        }
        
        updateCallback(endValue);
        onComplete?.Invoke();
    }
    
    IEnumerator AnimateColor(Color startColor, Color endColor, float duration, System.Action&lt;Color&gt; updateCallback, EasingType easing, System.Action onComplete = null)
    {
        float elapsedTime = 0f;
        
        while (elapsedTime &lt; duration)
        {
            elapsedTime += GetDeltaTime();
            float t = Mathf.Clamp01(elapsedTime / duration);
            float easedT = ApplyEasing(t, easing);
            Color currentColor = Color.Lerp(startColor, endColor, easedT);
            
            updateCallback(currentColor);
            yield return null;
        }
        
        updateCallback(endColor);
        onComplete?.Invoke();
    }
    
    // Animation management
    void TrackAnimation(GameObject target, Coroutine animation)
    {
        if (!activeAnimations.ContainsKey(target))
        {
            activeAnimations[target] = new List&lt;Coroutine&gt;();
        }
        
        activeAnimations[target].Add(animation);
    }
    
    void StopAnimations(GameObject target)
    {
        if (activeAnimations.ContainsKey(target))
        {
            foreach (Coroutine animation in activeAnimations[target])
            {
                if (animation != null)
                {
                    StopCoroutine(animation);
                }
            }
            
            activeAnimations[target].Clear();
        }
    }
    
    // Utility methods
    float GetDeltaTime()
    {
        return (useUnscaledTime ? Time.unscaledDeltaTime : Time.deltaTime) * globalAnimationSpeed;
    }
    
    float ApplyEasing(float t, EasingType easing)
    {
        switch (easing)
        {
            case EasingType.Linear: return t;
            case EasingType.EaseIn: return t * t;
            case EasingType.EaseOut: return 1f - (1f - t) * (1f - t);
            case EasingType.EaseInOut: return t &lt; 0.5f ? 2f * t * t : 1f - Mathf.Pow(-2f * t + 2f, 2f) / 2f;
            case EasingType.EaseOutBack: return 1f + 2.70158f * Mathf.Pow(t - 1f, 3f) + 1.70158f * Mathf.Pow(t - 1f, 2f);
            case EasingType.EaseOutBounce: return ApplyBounceEasing(t);
            default: return t;
        }
    }
    
    float ApplyBounceEasing(float t)
    {
        if (t &lt; 1f / 2.75f)
        {
            return 7.5625f * t * t;
        }
        else if (t &lt; 2f / 2.75f)
        {
            return 7.5625f * (t -= 1.5f / 2.75f) * t + 0.75f;
        }
        else if (t &lt; 2.5f / 2.75f)
        {
            return 7.5625f * (t -= 2.25f / 2.75f) * t + 0.9375f;
        }
        else
        {
            return 7.5625f * (t -= 2.625f / 2.75f) * t + 0.984375f;
        }
    }
}

[System.Serializable]
public class AnimationSettings
{
    public float duration = 0.3f;
    public EasingType easing = EasingType.EaseOut;
    public System.Action onComplete;
}

public enum EasingType
{
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    EaseOutBack,
    EaseOutBounce
}

public enum SlideDirection
{
    Left,
    Right,
    Up,
    Down
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>
            </section>

            <section>
                <h2>Performance Optimization for UI</h2>
                
                <p>UI performance can significantly impact your game's framerate, especially on mobile devices. Unity's UI system uses a batching approach where elements on the same Canvas are drawn together, but complex hierarchies and frequent updates can cause performance bottlenecks.</p>

                <div class="code-example">
                    <h4>UI Performance Monitor and Optimizer</h4>
                    <pre><code class="language-csharp">using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

public class UIPerformanceManager : MonoBehaviour
{
    [Header("Performance Monitoring")]
    public bool enablePerformanceMonitoring = true;
    public float monitoringInterval = 1f;
    public bool logPerformanceWarnings = true;
    
    [Header("Optimization Settings")]
    public bool enableAutoOptimization = true;
    public int maxUIElementsPerCanvas = 100;
    public int maxCanvasRebuildPerFrame = 5;
    
    [Header("Debug Display")]
    public bool showPerformanceOverlay = false;
    public KeyCode toggleOverlayKey = KeyCode.F2;
    
    // Performance tracking
    private Dictionary&lt;Canvas, CanvasPerformanceData&gt; canvasPerformance = new Dictionary&lt;Canvas, CanvasPerformanceData&gt;();
    private float lastMonitoringTime;
    private int frameRebuildCount = 0;
    
    // UI element pools for optimization
    private Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; uiElementPools = new Dictionary&lt;string, Queue&lt;GameObject&gt;&gt;();
    
    void Update()
    {
        HandleInput();
        
        if (enablePerformanceMonitoring &amp;&amp; Time.time - lastMonitoringTime &gt;= monitoringInterval)
        {
            MonitorUIPerformance();
            lastMonitoringTime = Time.time;
        }
        
        // Reset rebuild count each frame
        frameRebuildCount = 0;
    }
    
    void HandleInput()
    {
        if (Input.GetKeyDown(toggleOverlayKey))
        {
            showPerformanceOverlay = !showPerformanceOverlay;
        }
    }
    
    void MonitorUIPerformance()
    {
        Canvas[] allCanvases = FindObjectsOfType&lt;Canvas&gt;();
        
        foreach (Canvas canvas in allCanvases)
        {
            AnalyzeCanvasPerformance(canvas);
        }
        
        if (enableAutoOptimization)
        {
            ApplyAutomaticOptimizations();
        }
    }
    
    void AnalyzeCanvasPerformance(Canvas canvas)
    {
        if (canvas == null) return;
        
        CanvasPerformanceData data = GetOrCreatePerformanceData(canvas);
        
        // Count UI elements
        data.totalUIElements = CountUIElements(canvas.transform);
        data.visibleUIElements = CountVisibleUIElements(canvas.transform);
        
        // Analyze layout components
        data.layoutComponents = CountLayoutComponents(canvas.transform);
        
        // Check for performance issues
        data.hasPerformanceIssues = IdentifyPerformanceIssues(canvas, data);
        
        // Update Canvas stats
        GraphicRaycaster raycaster = canvas.GetComponent&lt;GraphicRaycaster&gt;();
        data.raycastEnabled = raycaster != null &amp;&amp; raycaster.enabled;
        
        CanvasScaler scaler = canvas.GetComponent&lt;CanvasScaler&gt;();
        data.hasCanvasScaler = scaler != null;
        
        if (logPerformanceWarnings &amp;&amp; data.hasPerformanceIssues)
        {
            LogPerformanceWarnings(canvas, data);
        }
    }
    
    CanvasPerformanceData GetOrCreatePerformanceData(Canvas canvas)
    {
        if (!canvasPerformance.ContainsKey(canvas))
        {
            canvasPerformance[canvas] = new CanvasPerformanceData();
        }
        return canvasPerformance[canvas];
    }
    
    int CountUIElements(Transform parent)
    {
        int count = 0;
        
        // Count immediate children with UI components
        foreach (Transform child in parent)
        {
            if (HasUIComponents(child.gameObject))
            {
                count++;
            }
            
            // Recursively count children
            count += CountUIElements(child);
        }
        
        return count;
    }
    
    int CountVisibleUIElements(Transform parent)
    {
        int count = 0;
        
        foreach (Transform child in parent)
        {
            if (child.gameObject.activeInHierarchy &amp;&amp; HasUIComponents(child.gameObject))
            {
                Graphic graphic = child.GetComponent&lt;Graphic&gt;();
                if (graphic == null || graphic.color.a &gt; 0f)
                {
                    count++;
                }
            }
            
            count += CountVisibleUIElements(child);
        }
        
        return count;
    }
    
    int CountLayoutComponents(Transform parent)
    {
        int count = 0;
        
        foreach (Transform child in parent)
        {
            // Count layout components
            if (child.GetComponent&lt;LayoutGroup&gt;() != null ||
                child.GetComponent&lt;ContentSizeFitter&gt;() != null ||
                child.GetComponent&lt;AspectRatioFitter&gt;() != null)
            {
                count++;
            }
            
            count += CountLayoutComponents(child);
        }
        
        return count;
    }
    
    bool HasUIComponents(GameObject obj)
    {
        return obj.GetComponent&lt;Graphic&gt;() != null ||
               obj.GetComponent&lt;Selectable&gt;() != null ||
               obj.GetComponent&lt;LayoutElement&gt;() != null;
    }
    
    bool IdentifyPerformanceIssues(Canvas canvas, CanvasPerformanceData data)
    {
        bool hasIssues = false;
        
        // Too many UI elements
        if (data.totalUIElements &gt; maxUIElementsPerCanvas)
        {
            data.issues.Add($"Too many UI elements: {data.totalUIElements} (max recommended: {maxUIElementsPerCanvas})");
            hasIssues = true;
        }
        
        // Excessive layout components
        if (data.layoutComponents &gt; 10)
        {
            data.issues.Add($"High number of layout components: {data.layoutComponents}");
            hasIssues = true;
        }
        
        // Multiple Canvas components in hierarchy
        Canvas[] childCanvases = canvas.GetComponentsInChildren&lt;Canvas&gt;();
        if (childCanvases.Length &gt; 1)
        {
            data.issues.Add($"Multiple nested canvases: {childCanvases.Length}");
            hasIssues = true;
        }
        
        // Raycast optimization
        if (data.raycastEnabled &amp;&amp; data.totalUIElements &gt; 50)
        {
            data.issues.Add("Raycasting enabled on large canvas - consider optimization");
            hasIssues = true;
        }
        
        return hasIssues;
    }
    
    void LogPerformanceWarnings(Canvas canvas, CanvasPerformanceData data)
    {
        Debug.LogWarning($"Performance issues detected on Canvas '{canvas.name}':");
        
        foreach (string issue in data.issues)
        {
            Debug.LogWarning($"  - {issue}");
        }
    }
    
    void ApplyAutomaticOptimizations()
    {
        foreach (var kvp in canvasPerformance)
        {
            Canvas canvas = kvp.Key;
            CanvasPerformanceData data = kvp.Value;
            
            if (canvas == null || !data.hasPerformanceIssues) continue;
            
            OptimizeCanvas(canvas, data);
        }
    }
    
    void OptimizeCanvas(Canvas canvas, CanvasPerformanceData data)
    {
        // Disable raycast on non-interactive elements
        OptimizeRaycasting(canvas.transform);
        
        // Optimize layout components
        OptimizeLayoutComponents(canvas.transform);
        
        // Consider canvas separation for highly dynamic elements
        if (data.totalUIElements &gt; maxUIElementsPerCanvas)
        {
            Debug.Log($"Consider separating Canvas '{canvas.name}' - {data.totalUIElements} elements detected");
        }
    }
    
    void OptimizeRaycasting(Transform parent)
    {
        foreach (Transform child in parent)
        {
            Graphic graphic = child.GetComponent&lt;Graphic&gt;();
            if (graphic != null &amp;&amp; !IsInteractiveElement(child.gameObject))
            {
                graphic.raycastTarget = false;
            }
            
            OptimizeRaycasting(child);
        }
    }
    
    bool IsInteractiveElement(GameObject obj)
    {
        return obj.GetComponent&lt;Selectable&gt;() != null ||
               obj.GetComponent&lt;IPointerClickHandler&gt;() != null ||
               obj.GetComponent&lt;IPointerDownHandler&gt;() != null ||
               obj.GetComponent&lt;IPointerUpHandler&gt;() != null ||
               obj.GetComponent&lt;IDragHandler&gt;() != null ||
               obj.GetComponent&lt;IDropHandler&gt;() != null;
    }
    
    void OptimizeLayoutComponents(Transform parent)
    {
        foreach (Transform child in parent)
        {
            // Disable unnecessary layout components on static elements
            LayoutElement layoutElement = child.GetComponent&lt;LayoutElement&gt;();
            if (layoutElement != null &amp;&amp; !IsLayoutElementNecessary(child))
            {
                layoutElement.ignoreLayout = true;
            }
            
            OptimizeLayoutComponents(child);
        }
    }
    
    bool IsLayoutElementNecessary(Transform element)
    {
        // Check if element is part of a layout group
        Transform parent = element.parent;
        while (parent != null)
        {
            if (parent.GetComponent&lt;LayoutGroup&gt;() != null)
            {
                return true;
            }
            parent = parent.parent;
        }
        
        return false;
    }
    
    // UI Element Pooling System
    public GameObject GetPooledUIElement(string poolName, GameObject prefab)
    {
        if (!uiElementPools.ContainsKey(poolName))
        {
            uiElementPools[poolName] = new Queue&lt;GameObject&gt;();
        }
        
        Queue&lt;GameObject&gt; pool = uiElementPools[poolName];
        
        if (pool.Count &gt; 0)
        {
            GameObject pooledObj = pool.Dequeue();
            pooledObj.SetActive(true);
            return pooledObj;
        }
        else
        {
            return Instantiate(prefab);
        }
    }
    
    public void ReturnToPool(string poolName, GameObject obj)
    {
        if (!uiElementPools.ContainsKey(poolName))
        {
            uiElementPools[poolName] = new Queue&lt;GameObject&gt;();
        }
        
        obj.SetActive(false);
        uiElementPools[poolName].Enqueue(obj);
    }
    
    // Canvas rebuild tracking
    public void OnCanvasRebuilt(Canvas canvas)
    {
        frameRebuildCount++;
        
        if (frameRebuildCount &gt; maxCanvasRebuildPerFrame)
        {
            Debug.LogWarning($"High Canvas rebuild count this frame: {frameRebuildCount}");
        }
    }
    
    // Debug display
    void OnGUI()
    {
        if (!showPerformanceOverlay) return;
        
        int yOffset = 10;
        int lineHeight = 20;
        
        GUI.Box(new Rect(10, yOffset, 400, canvasPerformance.Count * lineHeight * 4 + 40), "UI Performance Monitor");
        yOffset += 25;
        
        foreach (var kvp in canvasPerformance)
        {
            Canvas canvas = kvp.Key;
            CanvasPerformanceData data = kvp.Value;
            
            if (canvas == null) continue;
            
            string status = data.hasPerformanceIssues ? "[ISSUES]" : "[OK]";
            Color originalColor = GUI.color;
            GUI.color = data.hasPerformanceIssues ? Color.red : Color.green;
            
            GUI.Label(new Rect(20, yOffset, 380, lineHeight), $"{canvas.name} {status}");
            yOffset += lineHeight;
            
            GUI.color = originalColor;
            
            GUI.Label(new Rect(30, yOffset, 360, lineHeight), $"Elements: {data.totalUIElements} (Visible: {data.visibleUIElements})");
            yOffset += lineHeight;
            
            GUI.Label(new Rect(30, yOffset, 360, lineHeight), $"Layout Components: {data.layoutComponents}");
            yOffset += lineHeight;
            
            if (data.hasPerformanceIssues &amp;&amp; data.issues.Count &gt; 0)
            {
                GUI.color = Color.yellow;
                GUI.Label(new Rect(30, yOffset, 360, lineHeight), $"Issues: {data.issues.Count}");
                GUI.color = originalColor;
            }
            
            yOffset += lineHeight + 5;
        }
        
        yOffset += 10;
        GUI.Label(new Rect(20, yOffset, 380, lineHeight), $"Canvas rebuilds this frame: {frameRebuildCount}");
    }
}

[System.Serializable]
public class CanvasPerformanceData
{
    public int totalUIElements;
    public int visibleUIElements;
    public int layoutComponents;
    public bool hasPerformanceIssues;
    public bool raycastEnabled;
    public bool hasCanvasScaler;
    public List&lt;string&gt; issues = new List&lt;string&gt;();
}</code></pre>
                    <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
                </div>
            </section>

            <section>
                <h2>Key Takeaways</h2>
                
                <p>Unity's UI system provides a comprehensive framework for building responsive, interactive user interfaces. By understanding Canvas rendering modes, responsive design principles, event-driven programming, and performance optimization techniques, you can create polished interfaces that enhance your game's user experience.</p>

                <div class="info-box">
                    <h4>UI Development Best Practices</h4>
                    <ul>
                        <li>Separate static and dynamic UI elements onto different Canvases</li>
                        <li>Use anchor points and Canvas Scaler for responsive design across screen sizes</li>
                        <li>Disable raycast targets on non-interactive elements to improve performance</li>
                        <li>Implement object pooling for frequently created/destroyed UI elements</li>
                        <li>Use Canvas Groups for efficient batch operations on UI hierarchies</li>
                        <li>Profile UI performance regularly, especially on target mobile devices</li>
                        <li>Create reusable UI components with clear APIs and configuration options</li>
                    </ul>
                </div>

                <p>The UI system works hand-in-hand with other Unity systems like audio for button feedback, animation for smooth transitions, and input handling for user interactions. In the next chapter, we'll explore Unity's audio and visual effects systems to add polish and atmosphere to your game.</p>
            </section>

            <div class="chapter-nav">
                <a href="chapter06.html" class="nav-button prev">â† Previous: Physics & Collisions</a>
                <a href="chapter08.html" class="nav-button next">Next: Audio & Visual Effects â†’</a>
            </div>
        </article>
        </div>
    </main>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        // Initialize syntax highlighting
        hljs.highlightAll();

        // Sidebar toggle for mobile
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        // Copy code functionality
        function copyCode(button) {
            const codeBlock = button.parentElement.querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Progress bar
        window.addEventListener('scroll', () => {
            const scrolled = window.scrollY;
            const height = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (scrolled / height) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        });

        // Active navigation highlighting
        const currentPage = window.location.pathname.split('/').pop() || 'index.html';
        document.querySelectorAll('.sidebar a').forEach(link => {
            if (link.getAttribute('href') === currentPage) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });
    </script>
</body>
</html>